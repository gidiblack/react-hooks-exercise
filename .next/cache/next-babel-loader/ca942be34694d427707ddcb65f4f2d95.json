{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useEffect, useState, useReducer } from 'react';\nimport axios from \"axios\";\n\nvar dataFetchReducer = function dataFetchReducer(state, action) {\n  switch (action.type) {\n    case \"FETCH_INIT\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: true,\n        isError: false\n      });\n\n    case \"FECTH_SUCCESS\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: false,\n        errorMessage: \"\",\n        data: action.payload\n      });\n\n    case \"FETCH_FAILURE\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: true,\n        errorMessage: \"Data Retrieve Failure\"\n      });\n\n    case \"REPLACE_DATA\":\n      // The record parsed (state.data) must had attribute \"id\"\n      var newData = state.data.map(function (rec) {\n        return rec.id === action.replacerecord.id ? action.replacerecord : rec;\n      });\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: false,\n        errorMessage: \"\",\n        data: newData\n      });\n\n    default:\n      throw Error();\n  }\n}; // REST data fetch call that takes a URL to call then ansynchronously return data\n// this hook needs to survive state changes so initial url and data need to be parsed as parameters to return data immediately that will be used before the REST data is fetched\n\n\nvar useAxiosFetch = function useAxiosFetch(initialUrl, initialData) {\n  _s();\n\n  var _useState = useState(initialUrl),\n      url = _useState[0]; // useReducer call that returns the state values for initial load\n\n\n  var _useReducer = useReducer(dataFetchReducer, {\n    isLoading: false,\n    hasErrored: false,\n    errorMessage: '',\n    data: initialData\n  }),\n      state = _useReducer[0],\n      dispatch = _useReducer[1]; // useEffect hook that executes when the component first is called with an async function to satisfy useEffect rules\n\n\n  useEffect(function () {\n    var didCancel = false; // async function\n\n    var fetchData = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // dispatch to reducer\n                dispatch({\n                  type: \"FETCH_INIT\"\n                }); // try to fetch data with axios\n\n                _context.prev = 1;\n                _context.next = 4;\n                return axios.get(url);\n\n              case 4:\n                result = _context.sent;\n\n                // if success dispatch success\n                if (!didCancel) {\n                  dispatch({\n                    type: \"FETCH_SUCCESS\",\n                    payload: result.data\n                  });\n                }\n\n                _context.next = 11;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](1);\n\n                // if error dispatch failure\n                if (!didCancel) {\n                  dispatch({\n                    type: \"FETCH_FAILURE\"\n                  });\n                }\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 8]]);\n      }));\n\n      return function fetchData() {\n        return _ref.apply(this, arguments);\n      };\n    }(); // call async function\n\n\n    fetchData();\n    return function () {\n      didCancel = true;\n    };\n  }, [url]); // function to update one data record\n\n  var updateRecord = function updateRecord(record) {\n    dispatch({\n      type: \"REPLACE_DATA\",\n      replacerecord: record\n    });\n  }; // return all the attributes of state and updateRecord function\n\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    updateRecord: updateRecord\n  });\n};\n\n_s(useAxiosFetch, \"Gr7Xat3+35pvybQ2vWk/9H2v/uM=\");\n\nexport default useAxiosFetch;","map":{"version":3,"sources":["C:/Users/GIDEON/Desktop/Web Projects/React/conference/src/useAxiosFetch.js"],"names":["React","useEffect","useState","useReducer","axios","dataFetchReducer","state","action","type","isLoading","isError","hasErrored","errorMessage","data","payload","newData","map","rec","id","replacerecord","Error","useAxiosFetch","initialUrl","initialData","url","dispatch","didCancel","fetchData","get","result","updateRecord","record"],"mappings":"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","sourcesContent":["import React, { useEffect, useState, useReducer } from 'react';\r\nimport axios from \"axios\";\r\n\r\nconst dataFetchReducer = (state, action) => {\r\n    switch (action.type){\r\n        case \"FETCH_INIT\":\r\n            return {\r\n                ...state, \r\n                isLoading: true, \r\n                isError: false\r\n            };\r\n        \r\n        case \"FECTH_SUCCESS\":\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                hasErrored : false,\r\n                errorMessage: \"\",\r\n                data: action.payload\r\n            };\r\n\r\n        case \"FETCH_FAILURE\":\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                hasErrored: true,\r\n                errorMessage: \"Data Retrieve Failure\"\r\n            };\r\n\r\n        case \"REPLACE_DATA\":\r\n            // The record parsed (state.data) must had attribute \"id\"\r\n            const newData = state.data.map(rec => {\r\n                return rec.id === action.replacerecord.id ? action.replacerecord : rec;\r\n            });\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                hasErrored: false,\r\n                errorMessage: \"\",\r\n                data: newData\r\n            };\r\n        default:\r\n            throw Error();\r\n    }\r\n};\r\n\r\n// REST data fetch call that takes a URL to call then ansynchronously return data\r\n// this hook needs to survive state changes so initial url and data need to be parsed as parameters to return data immediately that will be used before the REST data is fetched\r\nconst useAxiosFetch = (initialUrl, initialData) => {\r\n    const [url] = useState(initialUrl);\r\n    // useReducer call that returns the state values for initial load\r\n    const [state, dispatch] = useReducer(dataFetchReducer, {\r\n        isLoading: false,\r\n        hasErrored: false,\r\n        errorMessage: '',\r\n        data: initialData\r\n    });\r\n    // useEffect hook that executes when the component first is called with an async function to satisfy useEffect rules\r\n    useEffect(() => {\r\n        let didCancel = false;\r\n        // async function\r\n        const fetchData = async () => {\r\n            // dispatch to reducer\r\n            dispatch({ type: \"FETCH_INIT\"});\r\n            // try to fetch data with axios\r\n            try {\r\n                let result = await axios.get(url);\r\n                // if success dispatch success\r\n                if (!didCancel){\r\n                    dispatch({type: \"FETCH_SUCCESS\", payload: result.data });\r\n                }\r\n            } catch (err) {\r\n                // if error dispatch failure\r\n                if (!didCancel){\r\n                    dispatch({ type: \"FETCH_FAILURE\"});\r\n                }\r\n            }\r\n        };\r\n        // call async function\r\n        fetchData();\r\n\r\n        return () => {\r\n            didCancel = true;\r\n        };\r\n    }, [url]);\r\n    // function to update one data record\r\n    const updateRecord = record => {\r\n        dispatch({\r\n            type: \"REPLACE_DATA\",\r\n            replacerecord: record\r\n        });\r\n    };\r\n    // return all the attributes of state and updateRecord function\r\n    return { ...state, updateRecord};\r\n};\r\n\r\nexport default useAxiosFetch;   "]},"metadata":{},"sourceType":"module"}