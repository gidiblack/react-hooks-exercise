{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useEffect, useState, useReducer } from 'react';\nimport axios from \"axios\";\n\nconst dataFetchReducer = (state, action) => {\n  switch (action.type) {\n    case \"FETCH_INIT\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: true,\n        isError: false\n      });\n\n    case \"FECTH_SUCCESS\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: false,\n        errorMessage: \"\",\n        data: action.payload\n      });\n\n    case \"FETCH_FAILURE\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: true,\n        errorMessage: \"Data Retrieve Failure\"\n      });\n\n    case \"REPLACE_DATA\":\n      // The record parsed (state.data) must had attribute \"id\"\n      const newData = state.data.map(rec => {\n        return rec.id === action.replacerecord.id ? action.replacerecord : rec;\n      });\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: false,\n        errorMessage: \"\",\n        data: newData\n      });\n\n    default:\n      throw Error();\n  }\n}; // REST data fetch call that takes a URL to call then ansynchronously return data\n// this hook needs to survive state changes so initial url and data need to be parsed as parameters to return data immediately that will be used before the REST data is fetched\n\n\nconst useAxiosFetch = (initialUrl, initialData) => {\n  const {\n    0: url\n  } = useState(initialUrl); // useReducer call that returns the state values for initial load\n\n  const {\n    0: state,\n    1: dispatch\n  } = useReducer(dataFetchReducer, {\n    isLoading: false,\n    hasErrored: false,\n    errorMessage: '',\n    data: initialData\n  }); // useEffect hook that executes when the component first is called with an async function to satisfy useEffect rules\n\n  useEffect(() => {\n    let didCancel = false; // async function\n\n    const fetchData = async () => {\n      // dispatch to reducer\n      dispatch({\n        type: \"FETCH_INIT\"\n      }); // try to fetch data with axios\n\n      try {\n        let result = await axios.get(url); // if success dispatch success\n\n        if (!didCancel) {\n          dispatch({\n            type: \"FETCH_SUCCESS\",\n            payload: result.data\n          });\n        }\n      } catch (err) {\n        // if error dispatch failure\n        if (!didCancel) {\n          dispatch({\n            type: \"FETCH_FAILURE\"\n          });\n        }\n      }\n    }; // call async function\n\n\n    fetchData();\n    return () => {\n      didCancel = true;\n    };\n  }, [url]); // function to update one data record\n\n  const updateRecord = record => {\n    dispatch({\n      type: \"REPLACE_DATA\",\n      replacerecord: record\n    });\n  }; // return all the attributes of state and updateRecord function\n\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    updateRecord\n  });\n};\n\nexport default useAxiosFetch;","map":{"version":3,"sources":["C:/Users/GIDEON/Desktop/Web Projects/React/conference/src/useAxiosFetch.js"],"names":["React","useEffect","useState","useReducer","axios","dataFetchReducer","state","action","type","isLoading","isError","hasErrored","errorMessage","data","payload","newData","map","rec","id","replacerecord","Error","useAxiosFetch","initialUrl","initialData","url","dispatch","didCancel","fetchData","result","get","err","updateRecord","record"],"mappings":"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","sourcesContent":["import React, { useEffect, useState, useReducer } from 'react';\r\nimport axios from \"axios\";\r\n\r\nconst dataFetchReducer = (state, action) => {\r\n    switch (action.type){\r\n        case \"FETCH_INIT\":\r\n            return {\r\n                ...state, \r\n                isLoading: true, \r\n                isError: false\r\n            };\r\n        \r\n        case \"FECTH_SUCCESS\":\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                hasErrored : false,\r\n                errorMessage: \"\",\r\n                data: action.payload\r\n            };\r\n\r\n        case \"FETCH_FAILURE\":\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                hasErrored: true,\r\n                errorMessage: \"Data Retrieve Failure\"\r\n            };\r\n\r\n        case \"REPLACE_DATA\":\r\n            // The record parsed (state.data) must had attribute \"id\"\r\n            const newData = state.data.map(rec => {\r\n                return rec.id === action.replacerecord.id ? action.replacerecord : rec;\r\n            });\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                hasErrored: false,\r\n                errorMessage: \"\",\r\n                data: newData\r\n            };\r\n        default:\r\n            throw Error();\r\n    }\r\n};\r\n\r\n// REST data fetch call that takes a URL to call then ansynchronously return data\r\n// this hook needs to survive state changes so initial url and data need to be parsed as parameters to return data immediately that will be used before the REST data is fetched\r\nconst useAxiosFetch = (initialUrl, initialData) => {\r\n    const [url] = useState(initialUrl);\r\n    // useReducer call that returns the state values for initial load\r\n    const [state, dispatch] = useReducer(dataFetchReducer, {\r\n        isLoading: false,\r\n        hasErrored: false,\r\n        errorMessage: '',\r\n        data: initialData\r\n    });\r\n    // useEffect hook that executes when the component first is called with an async function to satisfy useEffect rules\r\n    useEffect(() => {\r\n        let didCancel = false;\r\n        // async function\r\n        const fetchData = async () => {\r\n            // dispatch to reducer\r\n            dispatch({ type: \"FETCH_INIT\"});\r\n            // try to fetch data with axios\r\n            try {\r\n                let result = await axios.get(url);\r\n                // if success dispatch success\r\n                if (!didCancel){\r\n                    dispatch({type: \"FETCH_SUCCESS\", payload: result.data });\r\n                }\r\n            } catch (err) {\r\n                // if error dispatch failure\r\n                if (!didCancel){\r\n                    dispatch({ type: \"FETCH_FAILURE\"});\r\n                }\r\n            }\r\n        };\r\n        // call async function\r\n        fetchData();\r\n\r\n        return () => {\r\n            didCancel = true;\r\n        };\r\n    }, [url]);\r\n    // function to update one data record\r\n    const updateRecord = record => {\r\n        dispatch({\r\n            type: \"REPLACE_DATA\",\r\n            replacerecord: record\r\n        });\r\n    };\r\n    // return all the attributes of state and updateRecord function\r\n    return { ...state, updateRecord};\r\n};\r\n\r\nexport default useAxiosFetch;   "]},"metadata":{},"sourceType":"module"}